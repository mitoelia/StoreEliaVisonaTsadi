<html xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:MSHelp="http://msdn.microsoft.com/mshelp" xmlns:mshelp="http://msdn.microsoft.com/mshelp" xmlns:ddue="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:msxsl="urn:schemas-microsoft-com:xslt"><head><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8" /><META NAME="save" CONTENT="history" /><title>Informazioni sui tipi di cursore</title><meta name="Language" content="it-it" /><meta name="System.Keywords" content="tipi di cursore" /><meta name="Microsoft.Help.Id" content="4f4d3db7-4f76-450d-ab63-141237a4f034" /><meta name="Description" content="Nei database relazionali le operazioni vengono eseguite su set di righe completi. Il set di righe restituito da un'istruzione SELECT include tutte le righe che soddisfano le condizioni specificate nella clausola WHERE dell'istruzione." /><meta name="Microsoft.Help.ContentType" content="Concepts" /><link rel="stylesheet" type="text/css" href="../local/Classic.css" /><script type="text/javascript" src="../scripts/EventUtilities.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/SplitScreen.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/Dropdown.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/script_manifold.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/script_feedBack.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/CheckboxMenu.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/CommonUtilities.js">&amp;nbsp;</script><script type="text/javascript" src="../local/script_main.js">&amp;nbsp;</script></head><body><div id="header"><table id="bottomTable" cellpadding="0" cellspacing="0"><tr><td align="left"><span id="headerBold">Informazioni sui tipi di cursore</span></td></tr></table><table id="gradientTable"><tr><td class="nsrBottom" background="../icons/gradient.gif" /></tr></table></div><div id="mainSection"><div id="mainBody"><div class="introduction"><p>Nei database relazionali le operazioni vengono eseguite su set di righe completi. Il set di righe restituito da un'istruzione SELECT include tutte le righe che soddisfano le condizioni specificate nella clausola WHERE dell'istruzione. Il set di righe completo restituito dall'istruzione è noto come set di risultati. Le applicazioni non sono sempre in grado di gestire in modo efficiente un intero set di risultati come singola unità. In tali applicazioni deve essere pertanto disponibile un meccanismo per l'elaborazione di una singola riga o di un blocco di righe di dimensioni ridotte. I cursori sono un'estensione dei set di risultati che offrono tale meccanismo. </p><p>I cursori estendono le funzionalità di elaborazione dei set di risultati nei modi seguenti:</p><ul><li><p>Consentono il posizionamento in corrispondenza di righe specifiche del set di risultati.</p></li><li><p>Consentono di recuperare una riga o un blocco di righe dalla posizione corrente nel set di risultati.</p></li><li><p>Supportano le modifiche ai dati della riga in corrispondenza della posizione corrente nel set di risultati.</p></li><li><p>Supportano livelli diversi di visibilità per le modifiche apportate da altri utenti ai dati del database inclusi nel set di risultati.</p></li></ul><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>Per una descrizione completa dei tipi di cursore di SQL Server, vedere l'argomento "Tipi di cursore (Motore di database)" nella documentazione online di SQL Server.</p></div><p>La specifica JDBC fornisce supporto per cursori forward-only e scorrevoli sensibili o non sensibili alle modifiche apportate da altri processi e che possono essere di sola lettura o aggiornabili. Questa funzionalità viene fornita dalla classe <a href="eaffcff1-286c-459f-83da-3150778480c9.htm">SQLServerResultSet</a> di Microsoft JDBC Driver per SQL Server.</p></div><h1 class="heading">Osservazioni</h1><div id="sectionSection0" class="section" name="collapseableSection" style=""><p>Il driver JDBC supporta i tipi di cursore seguenti:</p><div class="tableSection"><table width="50%" cellspacing="2" cellpadding="5" frame="lhs"><tr><th><p>Tipo di set di </p><p>risultati (cursore)</p></th><th><p>Tipo di cursore di SQL Server</p></th><th><p>Caratteristiche</p></th><th><p>Proprietà</p><p>Metodo</p></th><th><p>Proprietà</p><p>responseBuffering</p></th><th><p>Descrizione</p></th></tr><tr><td><p>TYPE_FORWARD_ONLY (CONCUR_READ_ONLY)</p></td><td><p>N/D</p></td><td><p>Forward-only, di sola lettura</p></td><td><p>direct</p></td><td><p>full</p></td><td><p>L'applicazione deve eseguire una singola iterazione (in avanti) nel set di risultati. Si tratta del comportamento predefinito, corrispondente a un cursore TYPE_SS_DIRECT_FORWARD_ONLY. Tramite il driver viene letto l'intero set di risultati dal server caricandolo in memoria durante l'esecuzione dell'istruzione. </p></td></tr><tr><td><p>TYPE_FORWARD_ONLY (CONCUR_READ_ONLY)</p></td><td><p>N/D</p></td><td><p>Forward-only, di sola lettura</p></td><td><p>direct</p></td><td><p>adaptive</p></td><td><p>L'applicazione deve eseguire una singola iterazione (in avanti) nel set di risultati. Il comportamento corrisponde a quello di un cursore TYPE_SS_DIRECT_FORWARD_ONLY. Tramite il driver le righe vengono lette dal server quando vengono richieste dall'applicazione, riducendo così al minimo l'utilizzo della memoria sul lato client.</p></td></tr><tr><td><p>TYPE_FORWARD_ONLY (CONCUR_READ_ONLY)</p></td><td><p>Fast forward</p></td><td><p>Forward-only, di sola lettura</p></td><td><p>cursor</p></td><td><p>N/D</p></td><td><p>L'applicazione deve eseguire una singola iterazione (in avanti) nel set di risultati utilizzando un cursore server. Il comportamento è analogo a quello di un cursore TYPE_SS_SERVER_CURSOR_FORWARD_ONLY.</p><p>Le righe vengono recuperate dal server in blocchi specificati dalla dimensione di recupero.</p></td></tr><tr><td><p>TYPE_FORWARD_ONLY (CONCUR_UPDATABLE)</p></td><td><p>Dinamico (forward-only)</p></td><td><p>Forward-only, aggiornabile</p></td><td><p>N/D</p></td><td><p>N/D</p></td><td><p>L'applicazione deve eseguire una singola iterazione (in avanti) nel set di risultati per aggiornare una o più righe. </p><p>Le righe vengono recuperate dal server in blocchi specificati dalla dimensione di recupero.</p><p>Per impostazione predefinita, la dimensione di recupero viene fissata quando l'applicazione chiama il metodo <a href="233bf4f8-4758-42d0-a80b-33e34fa78027.htm">setFetchSize</a> dell'oggetto <a href="eaffcff1-286c-459f-83da-3150778480c9.htm">SQLServerResultSet</a>. </p><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>Il driver JDBC include una caratteristica di buffer adattivo che consente di recuperare i risultati dell'esecuzione di istruzioni da SQL Server quando questi sono necessari per l'applicazione e non tutti contemporaneamente. Se ad esempio l'applicazione deve recuperare una quantità di dati eccessiva per essere caricata completamente in memoria, il buffer adattivo consente all'applicazione client di recuperare tali dati sotto forma di flusso. </p><p>Il comportamento predefinito del driver è "<span sdata="langKeyword" value="adaptive"><span class="keyword">adaptive</span></span>". Per ottenere il buffer adattivo per i set di risultati aggiornabili forward-only, l'applicazione deve tuttavia chiamare in modo esplicito il metodo <a href="9f489835-6cda-4c8c-b139-079639a169cf.htm">setResponseBuffering</a> dell'oggetto <a href="ec24963c-8b51-4838-91e9-1fbfa2347451.htm">SQLServerStatement</a> fornendo un valore <span sdata="langKeyword" value="String"><span class="keyword">String</span></span> "<span sdata="langKeyword" value="adaptive&quot;"><span class="keyword">adaptive"</span></span>. Per un esempio di codice vedere <span sdata="link"><a href="76ecc05f-a77d-40a2-bab9-91a7fcf17347.htm">Esempio di aggiornamento di dati di grandi dimensioni</a></span>.</p></div></td></tr><tr><td><p>TYPE_SCROLL_INSENSITIVE</p></td><td><p>Statico</p></td><td><p>Scorrevole, non aggiornabile</p><p>Gli aggiornamenti, gli inserimenti e le eliminazioni di righe eseguiti esternamente non sono visibili.</p></td><td><p>N/D</p></td><td><p>N/D</p></td><td><p>L'applicazione richiede uno snapshot del database. Il set di risultati non è aggiornabile. È supportato solo CONCUR_READ_ONLY.  Tutti gli altri tipi di concorrenza generano un'eccezione, se utilizzati con questo tipo di cursore.</p><p>Le righe vengono recuperate dal server in blocchi specificati dalla dimensione di recupero.</p></td></tr><tr><td><p>TYPE_SCROLL_SENSITIVE</p><p>(CONCUR_READ_ONLY)</p></td><td><p>Keyset</p></td><td><p>Scorrevole, sola lettura. Gli aggiornamenti di righe eseguiti esternamente sono visibili e le eliminazioni vengono visualizzate come dati mancanti.</p><p>Gli inserimenti di righe eseguiti esternamente non sono visibili. </p></td><td><p>N/D</p></td><td><p>N/D</p></td><td><p>Nell'applicazione devono essere visualizzati i dati modificati solo per le righe esistenti.</p><p>Le righe vengono recuperate dal server in blocchi specificati dalla dimensione di recupero.</p></td></tr><tr><td><p>TYPE_SCROLL_SENSITIVE</p><p>(CONCUR_UPDATABLE, CONCUR_SS_SCROLL_LOCKS, CONCUR_SS_OPTIMISTIC_CC, CONCUR_SS_OPTIMISTIC_CCVAL)</p></td><td><p>Keyset</p></td><td><p>Scorrevole, aggiornabile </p><p>Gli aggiornamenti di righe eseguiti internamente ed esternamente sono visibili e le eliminazioni vengono visualizzate come dati mancanti. Gli inserimenti non sono visibili.</p></td><td><p>N/D</p></td><td><p>N/D</p></td><td><p>L'applicazione può modificare i dati nelle righe esistenti tramite l'oggetto <b>ResultSet</b>. L'applicazione deve inoltre essere in grado di visualizzare le modifiche apportate alle righe da altri esternamente all'oggetto <b>ResultSet</b>.</p><p>Le righe vengono recuperate dal server in blocchi specificati dalla dimensione di recupero.</p></td></tr><tr><td><p>TYPE_SS_DIRECT_FORWARD_ONLY</p></td><td><p>N/D</p></td><td><p>Forward-only, di sola lettura</p></td><td><p>N/D</p></td><td><p>full o adaptive</p></td><td><p>Valore intero = 2003. Fornisce un cursore sul lato client di sola lettura completamente memorizzato nel buffer. Non viene creato alcun cursore server.</p><p>È supportato solo il tipo di concorrenza CONCUR_READ_ONLY. Tutti gli altri tipi di concorrenza generano un'eccezione, se utilizzati con questo tipo di cursore.</p></td></tr><tr><td><p>TYPE_SS_SERVER_CURSOR_FORWARD_ONLY</p></td><td><p>Fast forward</p></td><td><p>Forward-only</p></td><td><p>N/D</p></td><td><p>N/D</p></td><td><p>Valore intero = 2004. Veloce, con accesso a tutti i dati tramite un cursore server. È aggiornabile quando viene utilizzato con il tipo di concorrenza CONCUR_UPDATABLE.</p><p>Le righe vengono recuperate dal server in blocchi specificati dalla dimensione di recupero.</p><p>Per ottenere il buffer adattivo per questo caso, l'applicazione deve chiamare in modo esplicito il metodo <a href="9f489835-6cda-4c8c-b139-079639a169cf.htm">setResponseBuffering</a> dell'oggetto <a href="ec24963c-8b51-4838-91e9-1fbfa2347451.htm">SQLServerStatement</a> fornendo un valore <span sdata="langKeyword" value="String"><span class="keyword">String</span></span> "<span sdata="langKeyword" value="adaptive&quot;"><span class="keyword">adaptive"</span></span>. Per un esempio di codice vedere <span sdata="link"><a href="76ecc05f-a77d-40a2-bab9-91a7fcf17347.htm">Esempio di aggiornamento di dati di grandi dimensioni</a></span>.</p></td></tr><tr><td><p>TYPE_SS_SCROLL_STATIC</p></td><td><p>Statico</p></td><td><p>Gli aggiornamenti di altri utenti non vengono riflessi.</p></td><td><p>N/D</p></td><td><p>N/D</p></td><td><p>Valore intero = 1004. L'applicazione richiede uno snapshot del database. Si tratta del sinonimo specifico di SQL Server per il tipo JDBC TYPE_SCROLL_INSENSITIVE ed è caratterizzato dallo stesso comportamento dell'impostazione di concorrenza.</p><p>Le righe vengono recuperate dal server in blocchi specificati dalla dimensione di recupero.</p></td></tr><tr><td><p>TYPE_SS_SCROLL_KEYSET</p><p>(CONCUR_READ_ONLY)</p></td><td><p>Keyset</p></td><td><p>Scorrevole, sola lettura. Gli aggiornamenti di righe eseguiti esternamente sono visibili e le eliminazioni vengono visualizzate come dati mancanti.</p><p>Gli inserimenti di righe eseguiti esternamente non sono visibili.</p></td><td><p>N/D</p></td><td><p>N/D</p></td><td><p>Valore intero = 1005. Nell'applicazione devono essere visualizzati i dati modificati per le righe esistenti. Si tratta del sinonimo specifico di SQL Server per il tipo JDBC TYPE_SCROLL_SENSITIVE ed è caratterizzato dallo stesso comportamento dell'impostazione di concorrenza.</p><p>Le righe vengono recuperate dal server in blocchi specificati dalla dimensione di recupero.</p></td></tr><tr><td><p>TYPE_SS_SCROLL_KEYSET</p><p>(CONCUR_UPDATABLE, CONCUR_SS_SCROLL_LOCKS, CONCUR_SS_OPTIMISTIC_CC, CONCUR_SS_OPTIMISTIC_CCVAL)</p></td><td><p>Keyset</p></td><td><p>Scorrevole, aggiornabile </p><p>Gli aggiornamenti di righe eseguiti internamente ed esternamente sono visibili e le eliminazioni vengono visualizzate come dati mancanti. Gli inserimenti non sono visibili.</p></td><td><p>N/D</p></td><td><p>N/D</p></td><td><p>Valore intero = 1005. Nell'applicazione devono essere modificati i dati oppure devono essere visualizzati i dati modificati solo per le righe esistenti. Si tratta del sinonimo specifico di SQL Server per il tipo JDBC TYPE_SCROLL_SENSITIVE ed è caratterizzato dallo stesso comportamento dell'impostazione di concorrenza.</p><p>Le righe vengono recuperate dal server in blocchi specificati dalla dimensione di recupero.</p></td></tr><tr><td><p>TYPE_SS_SCROLL_DYNAMIC</p><p>(CONCUR_READ_ONLY)</p></td><td><p>Dinamico</p></td><td><p>Scorrevole, sola lettura. </p><p>Gli aggiornamenti e gli inserimenti di righe eseguiti esternamente sono visibili e le eliminazioni vengono visualizzate come dati mancanti temporanei nel buffer di recupero corrente. </p></td><td><p>N/D</p></td><td><p>N/D</p></td><td><p>Valore intero = 1006. Nell'applicazione devono essere visualizzati i dati modificati per le righe esistenti, nonché le righe inserite ed eliminate nel corso della durata del cursore.</p><p>Le righe vengono recuperate dal server in blocchi specificati dalla dimensione di recupero.</p></td></tr><tr><td><p>TYPE_SS_SCROLL_DYNAMIC</p><p>(CONCUR_UPDATABLE, CONCUR_SS_SCROLL_LOCKS, CONCUR_SS_OPTIMISTIC_CC, CONCUR_SS_OPTIMISTIC_CCVAL)</p></td><td><p>Dinamico</p></td><td><p>Scorrevole, aggiornabile </p><p>Gli aggiornamenti e gli inserimenti di righe eseguiti esternamente e internamente sono visibili e le eliminazioni vengono visualizzate come dati mancanti temporanei nel buffer di recupero corrente.</p></td><td><p>N/D</p></td><td><p>N/D</p></td><td><p>Valore intero = 1006. L'applicazione può modificare i dati per le righe esistenti oppure inserire o eliminare righe tramite l'oggetto <b>ResultSet</b>. L'applicazione deve inoltre essere in grado di visualizzare le modifiche, gli inserimenti e le eliminazioni apportate da altri esternamente all'oggetto <b>ResultSet</b>.</p><p>Le righe vengono recuperate dal server in blocchi specificati dalla dimensione di recupero.</p></td></tr></table></div></div><h1 class="heading">Posizionamento dei cursori</h1><div id="sectionSection1" class="section" name="collapseableSection" style=""><p>I cursori TYPE_FORWARD_ONLY, TYPE_SS_DIRECT_FORWARD_ONLY e TYPE_SS_SERVER_CURSOR_FORWARD_ONLY supportano solo il metodo di posizionamento <a href="60248447-6908-4036-a779-a501453cd553.htm">next</a>.</p><p>Il cursore TYPE_SS_SCROLL_DYNAMIC non supporta i metodi <a href="638e8148-8ca0-4e1f-9ec2-04a11bc9809b.htm">absolute</a> e <a href="a266e3bc-05c2-44e2-9346-125ae6780216.htm">getRow</a>. È possibile ottenere un risultato simile a quello del metodo <b>absolute</b> tramite una combinazione di chiamate ai metodi <a href="67ed9447-7b10-4c87-98e7-f4c2e2470b3a.htm">first</a> e <a href="2bcdbb69-95fd-4ae8-8488-1a75a91fe2e0.htm">relative</a> per i cursori dinamici.</p><p>Il metodo <b>getRow</b> è supportato solo dai cursori TYPE_FORWARD_ONLY, TYPE_SS_DIRECT_FORWARD_ONLY, TYPE_SS_SERVER_CURSOR_FORWARD_ONLY, TYPE_SS_SCROLL_KEYSET e TYPE_SS_SCROLL_STATIC. Il metodo <b>getRow</b> con tutti i tipi di cursore forward-only restituisce il numero di righe lette fino a quel momento tramite il cursore.</p><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>Quando un'applicazione esegue una chiamata non supportata ai metodi di posizionamento del cursore o al metodo <b>getRow</b>, viene generata un'eccezione con il messaggio "L'operazione richiesta non è supportata con questo tipo di cursore".</p></div><p>Solo il cursore TYPE_SS_SCROLL_KEYSET e l'equivalente TYPE_SCROLL_SENSITIVE espongono le righe eliminate. Se il cursore viene posizionato in una riga eliminata, i valori della colonna non sono disponibili e il metodo <a href="9c6db315-e614-4604-b020-41af6a214cc1.htm">rowDeleted</a> restituisce "true". Le chiamate ai metodi <b>get&lt;Type&gt;</b> generano un'eccezione con il messaggio "Impossibile ottenere un valore da una riga eliminata". Le righe eliminate non possono essere aggiornate. Se si tenta di chiamare un metodo <b>update&lt;Type&gt;</b> in una riga eliminata, viene generata un'eccezione con il messaggio "Non è possibile aggiornare una riga eliminata". Il cursore TYPE_SS_SCROLL_DYNAMIC ha lo stesso comportamento fino a quando non viene tolto dal buffer di recupero corrente.</p><p>I cursori forward e dinamici espongono le righe eliminate in modo simile, ma solo fino a quando rimangono accessibili nel buffer di recupero. Per i cursori forward, questo comportamento è piuttosto lineare. Per i cursori dinamici, si tratta di un comportamento più complesso quando la dimensione di recupero è maggiore di 1. Un'applicazione può spostare il cursore avanti e indietro nella finestra definita dal buffer di recupero, ma la riga eliminata non viene più visualizzata all'uscita dal buffer di recupero originale in cui è stata aggiornata. Se non si desidera che in un'applicazione vengano visualizzate righe eliminate temporanee tramite i cursori dinamici, è necessario utilizzare un'istruzione FETCH RELATIVE con l'argomento 0.</p><p>Se i valori chiave della riga di un cursore TYPE_SS_SCROLL_KEYSET o TYPE_SCROLL_SENSITIVE vengono aggiornati con il cursore, la riga mantiene la propria posizione originale nel set di risultati, indipendentemente dal fatto che la riga aggiornata soddisfi i criteri di selezione del cursore. Se la riga è stata aggiornata all'esterno del cursore, nella posizione originale della riga verrà visualizzata una riga eliminata, ma la riga verrà visualizzata nel cursore solo se nel cursore era presente un'altra riga con i nuovi valori chiave, che tuttavia è stata eliminata. </p><p>Per i cursori dinamici, le righe aggiornate mantengono la posizione all'interno del buffer di recupero fino a quando la finestra definita dal buffer di recupero non viene chiusa. Successivamente, le righe aggiornate possono venire visualizzate in posizioni diverse nel set di risultati o scomparire completamente. Per le applicazioni in cui è necessario evitare le incoerenze temporanee nel set di risultati, è necessario utilizzare una dimensione di recupero pari a 1. L'impostazione predefinita è 8 righe con concorrenza CONCUR_SS_SCROLL_LOCKS e 128 righe con altre concorrenze.</p></div><h1 class="heading">Conversione dei cursori</h1><div id="sectionSection2" class="section" name="collapseableSection" style=""><p>Talvolta in SQL Server può essere implementato un tipo di cursore diverso da quello richiesto e questo comportamento è noto come conversione implicita del cursore o degradazione del cursore. Per ulteriori informazioni sulla conversione implicita del cursore, vedere l'argomento "Utilizzo della conversione implicita del cursore" nella documentazione online di SQL Server.</p><p>In SQL Server 2000 quando si aggiornano i dati tramite i set di risultati <b>ResultSet.TYPE_SCROLL_SENSITIVE</b> e <b>ResultSet.CONCUR_UPDATABLE</b> viene generata un'eccezione con il messaggio "Il cursore è READ ONLY". Questa eccezione si verifica perché in SQL Server 2000 è stata eseguita una conversione implicita del cursore per tale set di risultati e non è stato restituito il cursore aggiornabile richiesto.</p><p>Per ovviare a questo problema, è possibile scegliere una delle due soluzioni seguenti:</p><ul><li><p>Verificare che la tabella sottostante disponga di una chiave primaria.</p></li><li><p>Utilizzare <a href="d87afd89-3e75-402c-b844-1b434eb258df.htm">SQLServerResultSet.TYPE_SS_SCROLL_DYNAMIC</a> anziché <b>ResultSet.TYPE_SCROLL_SENSITIVE</b> durante la creazione di un'istruzione.</p></li></ul></div><h1 class="heading">Aggiornamento dei cursori</h1><div id="sectionSection3" class="section" name="collapseableSection" style=""><p>Gli aggiornamenti sul posto sono supportati per i cursori se la concorrenza e il tipo di cursore supportano gli aggiornamenti. Se il cursore non è posizionato in una riga aggiornabile nel set di risultati (nessuna chiamata al metodo <b>get&lt;Type&gt;</b> ha avuto esito positivo), una chiamata a un metodo <b>update&lt;Type&gt;</b> genera un'eccezione con il messaggio "Il set di risultati non ha una riga corrente". In base alla specifica JDBC viene generata un'eccezione quando viene chiamato un metodo di aggiornamento per una colonna di un cursore di tipo CONCUR_READ_ONLY. Nei casi in cui la riga non è aggiornabile, ad esempio a causa di un conflitto di concorrenza ottimistica come un aggiornamento o un'eliminazione in conflitto, l'eccezione potrebbe non venire generata fino a quando non viene chiamato il metodo <a href="363d1008-1396-4fc0-8e27-c9ba2499e7f1.htm">insertRow</a>, <a href="cfced0ca-a281-40dc-8d2f-370d5f0bf12b.htm">updateRow</a> o <a href="aa04a644-c7c2-4738-8b6e-7fea566d2c16.htm">deleteRow</a>.</p><p>Dopo una chiamata a <b>update&lt;Type&gt;</b>, non è possibile accedere alla colonna interessata tramite <b>get&lt;Type&gt;</b> fino a quando non viene chiamato il metodo <b>updateRow</b> o <a href="2ecacca4-f7bc-4f5d-886a-da7747fdccae.htm">cancelRowUpdates</a>. In questo modo è possibile evitare i problemi che possono verificarsi quando una colonna viene aggiornata utilizzando un tipo diverso da quello restituito dal server e le chiamate al metodo Get successive possono richiamare conversioni del tipo sul lato client che forniscono risultati non accurati. Le chiamate a <b>get&lt;Type&gt;</b> generano un'eccezione con il messaggio "Impossibile accedere alle colonne aggiornate fino a quando non è stato chiamato updateRow() o cancelRowUpdates()".</p><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>Se il metodo <b>updateRow</b> viene chiamato quando non è stata aggiornata alcuna colonna, il driver JDBC genera un'eccezione con un messaggio che indica che è stato chiamato il metodo updateRow () senza che siano state aggiornate le colonne.</p></div><p>Dopo la chiamata a <a href="f3c54bfe-d5b7-4f6e-ae6c-3e8954e5b1c9.htm">moveToInsertRow</a>, viene generata un'eccezione se nel set di risultati viene chiamato qualsiasi metodo ad eccezione di <b>get&lt;Type&gt;</b>, <b>update&lt;Type&gt;</b>, <b>insertRow,</b> e dei metodi di posizionamento del cursore, incluso <a href="9a7c754c-2d72-4207-b3bd-2afc6047fb3d.htm">moveToCurrentRow</a>. Il metodo <b>moveToInsertRow</b> consente di attivare in modo efficace la modalità di inserimento per il set di risultati e i metodi di posizionamento del cursore consentono di interrompere tale modalità. Le chiamate ai metodi di posizionamento relativo del cursore consentono di spostare il cursore rispetto alla posizione in cui si trovava prima della chiamata al metodo <b>moveToInsertRow</b>. Dopo le chiamate ai metodi di posizionamento del cursore, la posizione di destinazione finale del cursore diventa la nuova posizione del cursore.</p><p>Se la chiamata ai metodi di posizionamento del cursore eseguita in modalità di inserimento non ha esito positivo, la posizione del cursore dopo tale chiamata corrisponde alla posizione originale del cursore prima della chiamata a <b>moveToInsetRow</b>. Se il metodo <b>insertRow</b> ha esito negativo, il cursore rimane nella riga di inserimento e in modalità di inserimento.</p><p>Inizialmente, le colonne nella riga di inserimento hanno uno stato non inizializzato. Le chiamate al metodo <b>update&lt;Type&gt;</b> consentono di impostare lo stato delle colonne come inizializzato. Una chiamata al metodo <b>get&lt;Type&gt;</b> per una colonna non inizializzata genera un'eccezione. Una chiamata al metodo <b>insertRow</b> ripristina lo stato non inizializzato per tutte le colonne nella riga di inserimento.</p><p>Se quando viene chiamato il metodo <b>insertRow</b> vi sono colonne non inizializzate, in tali colonne viene inserito il relativo valore predefinito. Se non è disponibile un valore predefinito, ma la colonna ammette i valori Null, viene inserito NULL. Se non è disponibile un valore predefinito e la colonna non ammette i valori Null, il server restituisce un errore e viene generata un'eccezione.</p><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p /><p>Le chiamate al metodo <b>getRow</b> eseguite in modalità di inserimento restituiscono 0. </p><p>Il driver JDBC non supporta eliminazioni o aggiornamenti posizionati. In base alla specifica JDBC, il metodo <a href="3f3ec4f2-103a-4e16-9206-c5bd8639f946.htm">setCursorName</a> non ha effetto e il metodo <a href="e5b3af67-423a-4551-a4c6-a4bc076bd504.htm">getCursorName</a> quando viene chiamato genera un'eccezione. </p><p>I cursori di sola lettura e statici non sono mai aggiornabili. </p><p>In SQL Server i cursori server sono limitati a un singolo set di risultati. Se un batch o una stored procedure contiene più istruzioni, è necessario utilizzare un cursore client di sola lettura forward-only.</p></div></div><span id="seeAlsoSpan"><h1 class="heading">Vedere anche</h1></span><div id="seeAlsoSection" class="section" name="collapseableSection" style=""><div class="seeAlsoStyle"><span sdata="link"><a href="9ed5ad41-22e0-4e4a-8a79-10512db60d50.htm">Gestione dei set di risultati con il driver JDBC</a></span></div></div></div><div id="footer" class="section"><span id="feedbackarea">Inviare <a href="javascript:SubmitFeedback('DevDocs@Microsoft.com','','','','8.0.12060.10000','%0\dThank%20you%20for%20your%20feedback.%20The%20developer%20writing%20teams%20use%20your%20feedback%20to%20improve%20documentation.%20While%20we%20are%20reviewing%20your%20feedback,%20we%20may%20send%20you%20e-mail%20to%20ask%20for%20clarification%20or%20feedback%20on%20a%20solution.%20We%20do%20not%20use%20your%20e-mail%20address%20for%20any%20other%20purpose%20and%20we%20delete%20it%20after%20we%20finish%20our%20review.%0\AFor%20further%20information%20about%20the%20privacy%20policies%20of%20Microsoft,%20please%20see%20http://privacy.microsoft.com/it-it/default.aspx.%0\A%0\d','Customer%20Feedback');">commenti e suggerimenti</a> su questo argomento a Microsoft.</span><span id="copyrightarea"><p><a href="9bad553b-9e70-4696-8499-2e35f772a1e0.htm">© 2012 Microsoft. Tutti i diritti sono riservati.</a></p></span></div></div></body></html>