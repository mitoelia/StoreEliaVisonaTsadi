<html xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:MSHelp="http://msdn.microsoft.com/mshelp" xmlns:mshelp="http://msdn.microsoft.com/mshelp" xmlns:ddue="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:msxsl="urn:schemas-microsoft-com:xslt"><head><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8" /><META NAME="save" CONTENT="history" /><title>Informazioni sulle conversioni dei tipi di dati</title><meta name="Language" content="it-it" /><meta name="System.Keywords" content="conversioni dei tipi di dati" /><meta name="Microsoft.Help.Id" content="98fa7488-aac3-45b4-8aa4-83ed6ab638b4" /><meta name="Description" content="Per semplificare la conversione dei tipi di dati del linguaggio di programmazione Java in tipi di dati di SQL Server, in Microsoft JDBC Driver per SQL Server sono disponibili le conversioni dei tipi di dati necessarie in base alla specifica JDBC." /><meta name="Microsoft.Help.ContentType" content="Concepts" /><link rel="stylesheet" type="text/css" href="../local/Classic.css" /><script type="text/javascript" src="../scripts/EventUtilities.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/SplitScreen.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/Dropdown.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/script_manifold.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/script_feedBack.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/CheckboxMenu.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/CommonUtilities.js">&amp;nbsp;</script><script type="text/javascript" src="../local/script_main.js">&amp;nbsp;</script></head><body><div id="header"><table id="bottomTable" cellpadding="0" cellspacing="0"><tr><td align="left"><span id="headerBold">Informazioni sulle conversioni dei tipi di dati</span></td></tr></table><table id="gradientTable"><tr><td class="nsrBottom" background="../icons/gradient.gif" /></tr></table></div><div id="mainSection"><div id="mainBody"><div class="introduction"><p>Per semplificare la conversione dei tipi di dati del linguaggio di programmazione Java in tipi di dati di SQL Server, in Microsoft JDBC Driver per SQL Server sono disponibili le conversioni dei tipi di dati necessarie in base alla specifica JDBC. Per offrire maggiore flessibilità, tutti i tipi sono convertibili da e verso i tipi di dati <span sdata="langKeyword" value="Object"><span class="keyword">Object</span></span>, <span sdata="langKeyword" value="String"><span class="keyword">String</span></span> e <span sdata="langKeyword" value="byte[]"><span class="keyword">byte[]</span></span>. </p></div><h1 class="heading">Conversioni dei metodi di richiamo</h1><div id="sectionSection0" class="section" name="collapseableSection" style=""><p>Sulla base dei tipi di dati SQL Server, il grafico seguente contiene la mappa di conversione del driver JDBC per i metodi <b>get&lt;Type&gt;()</b> della classe <a href="eaffcff1-286c-459f-83da-3150778480c9.htm">SQLServerResultSet</a> e le conversioni supportate nei metodi <b>get&lt;Type&gt;</b> della classe <a href="30710a63-c05d-47d9-9cf9-c087a1c76373.htm">SQLServerCallableStatement</a>.</p><img alt="JDBCGetterConversions" src="../art/JDBCGetterConversions.gif" /><p>Sono disponibili tre categorie di conversione supportate dai metodi di richiamo del driver JDBC:</p><ul><li><p><span class="label">Senza perdita di dati (x)</span>: conversioni nei casi in cui il tipo di richiamo è inferiore o identico al tipo di server sottostante. Ad esempio, quando si esegue la chiamata a <b>getBigDecimal</b> in una colonna decimale del server sottostante, la conversione non è necessaria.</p></li><li><p><span class="label">Convertito (y)</span>: conversioni dai tipi di server numerici nei tipi di linguaggio Java in cui la conversione è regolare e segue le regole di conversione del linguaggio Java. In tali conversioni, la precisione viene sempre troncata, mai arrotondata, e l'overflow viene gestito come modulo del tipo di destinazione inferiore. Quando, ad esempio, si chiama <b>getInt</b> su una colonna <span sdata="langKeyword" value="decimal"><span class="keyword">decimal</span></span> sottostante che contiene "1,9999" il valore restituito sarà "1", oppure se il valore <span sdata="langKeyword" value="decimal"><span class="keyword">decimal</span></span> sottostante è "3000000000", il valore <span sdata="langKeyword" value="int"><span class="keyword">int</span></span> causa un overflow in "-1294967296".</p></li><li><p><span class="label">Dipendente dai dati (z)</span>: le conversioni dai tipi di caratteri sottostanti in tipi numerici richiedono che i tipi di caratteri contengano valori che è possibile convertire in quel determinato tipo. Non vengono eseguite altre conversioni. Se è troppo grande per il tipo di richiamo, il valore non sarà valido. Se, ad esempio, viene chiamato <b>getInt</b> su una colonna varchar(50) che contiene "53", il valore verrà restituito come <span sdata="langKeyword" value="int"><span class="keyword">int</span></span>. Se invece il valore sottostante è "xyz" o "3000000000", verrà generato un errore.</p></li></ul><p>Se <b>getString</b> viene chiamato su un tipo di dati colonna <span sdata="langKeyword" value="binary"><span class="keyword">binary</span></span>, <span sdata="langKeyword" value="varbinary"><span class="keyword">varbinary</span></span>, <span sdata="langKeyword" value="varbinary(max)"><span class="keyword">varbinary(max)</span></span> o <span sdata="langKeyword" value="image"><span class="keyword">image</span></span>, il valore verrà restituito come stringa esadecimale.</p></div><h1 class="heading">Conversioni dei metodi di aggiornamento</h1><div id="sectionSection1" class="section" name="collapseableSection" style=""><p>Per i dati Java tipizzati passati ai metodi <b>update&lt;Type&gt;()</b> della classe <a href="eaffcff1-286c-459f-83da-3150778480c9.htm">SQLServerResultSet</a> si applicano le seguenti conversioni.</p><img alt="JDBCUpdaterConversions" src="../art/JDBC_JDBCUpdatterConversions.gif" /><p>Sono disponibili tre categorie di conversione supportate dai metodi di aggiornamento del driver JDBC:</p><ul><li><p><span class="label">Senza perdita di dati (x)</span>: conversioni nei casi in cui il tipo di aggiornamento è inferiore o identico al tipo di server sottostante. Ad esempio, quando si esegue la chiamata a <b>updateBigDecimal</b> in una colonna decimale del server sottostante, la conversione non è necessaria.</p></li><li><p><span class="label">Convertito (y)</span>: conversioni dai tipi di server numerici nei tipi di linguaggio Java in cui la conversione è regolare e segue le regole di conversione del linguaggio Java. In tali conversioni, la precisione viene sempre troncata, mai arrotondata, e l'overflow viene gestito come modulo del tipo di destinazione, ovvero quello inferiore. Quando, ad esempio, si chiama <b>updateDecimal</b> su una colonna <span sdata="langKeyword" value="int"><span class="keyword">int</span></span> sottostante che contiene "1,9999" il valore restituito sarà "1", oppure se il valore <span sdata="langKeyword" value="decimal"><span class="keyword">decimal</span></span> sottostante è "3000000000", il valore <span sdata="langKeyword" value="int"><span class="keyword">int</span></span> causa un overflow in "-1294967296".</p></li><li><p><span class="label">Dipendente dai dati (z)</span>: le conversioni dai tipi di dati di origine sottostanti in tipi di dati di destinazione richiedono che i valori contenuti possano essere convertiti nei tipi di destinazione. Non vengono eseguite altre conversioni. Se è troppo grande per il tipo di richiamo, il valore non sarà valido. Se, ad esempio, <b>updateString</b> viene chiamato su una colonna int che contiene "53", l'aggiornamento verrà eseguito. Se invece il valore String sottostante è "foo" o "3000000000", verrà generato un errore.</p></li></ul><p>Quando <b>updateString</b> viene chiamato in un tipo di dati colonna <span sdata="langKeyword" value="binary"><span class="keyword">binary</span></span>, <span sdata="langKeyword" value="varbinary"><span class="keyword">varbinary</span></span>, <span sdata="langKeyword" value="varbinary(max)"><span class="keyword">varbinary(max)</span></span> o <span sdata="langKeyword" value="image"><span class="keyword">image</span></span>, il valore String verrà gestito come valore di stringa esadecimale.</p><p>Quando il tipo di dati colonna di SQL Server è <span sdata="langKeyword" value="XML"><span class="keyword">XML</span></span>, il valore dei dati deve essere un tipo <span sdata="langKeyword" value="XML"><span class="keyword">XML</span></span> valido. Quando si chiama il metodo <b>updateBytes</b>, <b>updateBinaryStream</b> o <b>updateBlob</b>, il valore dei dati deve essere la rappresentazione di stringa esadecimale dei caratteri XML. Ad esempio: </p><div class="sampleCode"><span codeLanguage="other"><pre>&lt;hello&gt;world&lt;/hello&gt; = 0x3C68656C6C6F3E776F726C643C2F68656C6C6F3E </pre></span></div><p>Si noti che se i caratteri XML sono espressi in codifiche di caratteri specifiche, è necessario un indicatore dell'ordine dei byte (BOM, Byte-Order Mark).</p></div><h1 class="heading">Conversioni dei metodi di impostazione</h1><div id="sectionSection2" class="section" name="collapseableSection" style=""><p>Per i tipi Java tipizzati passati ai metodi <b>set&lt;Type&gt;()</b> delle classi <a href="a8481c06-fbba-432b-8c69-4f4619c20ad4.htm">SQLServerPreparedStatement</a> e <a href="30710a63-c05d-47d9-9cf9-c087a1c76373.htm">SQLServerCallableStatement</a>, si applicano le seguenti conversioni.</p><img alt="JDBCSetterConversions" src="../art/JDBC_JDBCSetterConversions_v2.gif" /><p>Il server cercherà di eseguire la conversione e restituirà degli errori in caso di esito negativo.</p><p>Nel caso del tipo di dati <span sdata="langKeyword" value="String"><span class="keyword">String</span></span>, se il valore supera la lunghezza di <span sdata="langKeyword" value="VARCHAR"><span class="keyword">VARCHAR</span></span>, ne verrà eseguito il mapping a <span sdata="langKeyword" value="LONGVARCHAR"><span class="keyword">LONGVARCHAR</span></span>. Analogamente, nel caso del tipo di dati <span sdata="langKeyword" value="NVARCHAR"><span class="keyword">NVARCHAR</span></span>, se il valore supera la lunghezza di <span sdata="langKeyword" value="LONGNVARCHAR"><span class="keyword">LONGNVARCHAR</span></span>, ne verrà eseguito il mapping a <span sdata="langKeyword" value="NVARCHAR"><span class="keyword">NVARCHAR</span></span>. Lo stesso vale per <span sdata="langKeyword" value="byte[]"><span class="keyword">byte[]</span></span>. I valori più lunghi di <span sdata="langKeyword" value="VARBINARY"><span class="keyword">VARBINARY</span></span> diventano <span sdata="langKeyword" value="LONGVARBINARY"><span class="keyword">LONGVARBINARY</span></span>.</p><p>Sono disponibili due categorie di conversione supportate dai metodi di impostazione del driver JDBC:</p><ul><li><p><span class="label">Senza perdita di dati (x)</span>: conversioni nei casi numerici in cui il tipo di impostazione è inferiore o identico al tipo di server sottostante. Quando, ad esempio, si chiama <b>setBigDecimal</b> su una colonna <span sdata="langKeyword" value="decimal"><span class="keyword">decimal</span></span> del server sottostante, la conversione non è necessaria. Per la conversione da un tipo numeric a un tipo character, il tipo di dati <span sdata="langKeyword" value="numeric"><span class="keyword">numeric</span></span> Java viene convertito in <span sdata="langKeyword" value="String"><span class="keyword">String</span></span>. Ad esempio, la chiamata a <b>setDouble</b> con un valore pari a "53" in una colonna varchar(50) produrrà un valore character "53" nella colonna di destinazione.</p></li><li><p><span class="label">Convertito (y)</span>: conversioni da un tipo <span sdata="langKeyword" value="numeric"><span class="keyword">numeric</span></span> Java in un tipo <span sdata="langKeyword" value="numeric"><span class="keyword">numeric</span></span> del server sottostante inferiore. Questa conversione è regolare e segue le convenzioni di conversione di SQL Server. La precisione è sempre troncata, mai arrotondata, e l'overflow genera un errore di conversione non supportata. Ad esempio, utilizzando <b>updateDecimal</b> con un valore pari a "1,9999" in una colonna Integer sottostante verrà restituito "1" nella colonna di destinazione. Se invece viene passato "3000000000", verrà generato un errore.</p></li><li><p><span class="label">Dipendente dai dati (z)</span>: la conversione da un tipo <span sdata="langKeyword" value="String"><span class="keyword">String</span></span> Java al tipo di dati di SQL Server sottostante dipende dalle seguenti condizioni: il driver invia il valore <span sdata="langKeyword" value="String"><span class="keyword">String</span></span> a SQL Server e SQL Server esegue le conversioni eventualmente necessarie. Se la proprietà <b>sendStringParametersAsUnicode</b> è impostata su true e il tipo di dati di SQL Server sottostante è <span sdata="langKeyword" value="image"><span class="keyword">image</span></span>, in SQL Server non è consentita la conversione di tipi di dati <span sdata="langKeyword" value="nvarchar"><span class="keyword">nvarchar</span></span> in <span sdata="langKeyword" value="image"><span class="keyword">image</span></span> e viene generata un'eccezione <b>SQLServerException</b>. Se la proprietà sendStringParametersAsUnicode è impostata su false e il tipo di dati di SQL Server sottostante è <span sdata="langKeyword" value="image"><span class="keyword">image</span></span>, in SQL Server è consentita la conversione di tipi di dati <span sdata="langKeyword" value="varchar"><span class="keyword">varchar</span></span> in <span sdata="langKeyword" value="image"><span class="keyword">image</span></span> e non viene generata un'eccezione.</p></li></ul><p>SQL Server esegue le conversioni e restituisce gli errori al driver JDBC in caso di problemi.</p><p>Quando il tipo di dati colonna di SQL Server è <span sdata="langKeyword" value="XML"><span class="keyword">XML</span></span>, il valore dei dati deve essere un tipo <span sdata="langKeyword" value="XML"><span class="keyword">XML</span></span> valido. Quando si chiama il metodo <b>updateBytes</b>, <b>updateBinaryStream</b> o <b>updateBlob</b>, il valore dei dati deve essere la rappresentazione di stringa esadecimale dei caratteri XML. Ad esempio: </p><div class="sampleCode"><span codeLanguage="other"><pre>&lt;hello&gt;world&lt;/hello&gt; = 0x3C68656C6C6F3E776F726C643C2F68656C6C6F3E </pre></span></div><p>Si noti che se i caratteri XML sono espressi in codifiche di caratteri specifiche, è necessario un indicatore dell'ordine dei byte (BOM, Byte-Order Mark).</p></div><h1 class="heading">Conversioni in setObject</h1><div id="sectionSection3" class="section" name="collapseableSection" style=""><p>Per i dati Java tipizzati passati ai metodi <b>setObject(&lt;Type&gt;)</b> della classe <a href="a8481c06-fbba-432b-8c69-4f4619c20ad4.htm">SQLServerPreparedStatement</a>, si applicano le seguenti conversioni. </p><img alt="JDBCSetObjectConversions" src="../art/JDBC_JDBCSetObjectConversions.gif" /><p>Il metodo <b>setObject</b> senza alcun tipo di destinazione specificato utilizzerà il mapping predefinito. Nel caso del tipo di dati <span sdata="langKeyword" value="String"><span class="keyword">String</span></span>, se il valore supera la lunghezza di <span sdata="langKeyword" value="VARCHAR"><span class="keyword">VARCHAR</span></span>, ne verrà eseguito il mapping a <span sdata="langKeyword" value="LONGVARCHAR"><span class="keyword">LONGVARCHAR</span></span>. Analogamente, nel caso del tipo di dati <span sdata="langKeyword" value="NVARCHAR"><span class="keyword">NVARCHAR</span></span>, se il valore supera la lunghezza di <span sdata="langKeyword" value="LONGNVARCHAR"><span class="keyword">LONGNVARCHAR</span></span>, ne verrà eseguito il mapping a <span sdata="langKeyword" value="NVARCHAR"><span class="keyword">NVARCHAR</span></span>. Lo stesso vale per <span sdata="langKeyword" value="byte[]"><span class="keyword">byte[]</span></span>. I valori più lunghi di <span sdata="langKeyword" value="VARBINARY"><span class="keyword">VARBINARY</span></span> diventano <span sdata="langKeyword" value="LONGVARBINARY"><span class="keyword">LONGVARBINARY</span></span>.</p><p>Sono disponibili tre categorie di conversione supportate dai metodi setObject del driver JDBC:</p><ul><li><p><span class="label">Senza perdita di dati (x)</span>: conversioni nei casi numerici in cui il tipo di impostazione è inferiore o identico al tipo di server sottostante. Quando, ad esempio, si chiama <b>setBigDecimal</b> su una colonna <span sdata="langKeyword" value="decimal"><span class="keyword">decimal</span></span> del server sottostante, la conversione non è necessaria. Per la conversione da un tipo numeric a un tipo character, il tipo di dati <span sdata="langKeyword" value="numeric"><span class="keyword">numeric</span></span> Java viene convertito in <span sdata="langKeyword" value="String"><span class="keyword">String</span></span>. Ad esempio, la chiamata a <b>setDouble</b> con un valore di "53" in una colonna varchar(50) produrrà un valore character "53" nella colonna di destinazione.</p></li><li><p><span class="label">Convertito (y)</span>: conversioni da un tipo <span sdata="langKeyword" value="numeric"><span class="keyword">numeric</span></span> Java in un tipo <span sdata="langKeyword" value="numeric"><span class="keyword">numeric</span></span> del server sottostante inferiore. Questa conversione è regolare e segue le convenzioni di conversione di SQL Server. La precisione è sempre troncata, mai arrotondata, e l'overflow genera un errore di conversione non supportata. Ad esempio, utilizzando <b>updateDecimal</b> con un valore pari a "1,9999" in una colonna Integer sottostante verrà restituito "1" nella colonna di destinazione. Se invece viene passato "3000000000", verrà generato un errore.</p></li><li><p><span class="label">Dipendente dai dati (z)</span>: la conversione da un tipo <span sdata="langKeyword" value="String"><span class="keyword">String</span></span> Java al tipo di dati di SQL Server sottostante dipende dalle seguenti condizioni: il driver invia il valore <span sdata="langKeyword" value="String"><span class="keyword">String</span></span> a SQL Server e SQL Server esegue le conversioni eventualmente necessarie. Se la proprietà di connessione <b>sendStringParametersAsUnicode</b> è impostata su true e il tipo di dati di SQL Server sottostante è <span sdata="langKeyword" value="image"><span class="keyword">image</span></span>, in SQL Server non è consentita la conversione di tipi di dati <span sdata="langKeyword" value="nvarchar"><span class="keyword">nvarchar</span></span> in <span sdata="langKeyword" value="image"><span class="keyword">image</span></span> e viene generata un'eccezione SQLServerException. Se la proprietà <b>sendStringParametersAsUnicode</b> è impostata su false e il tipo di dati di SQL Server sottostante è <span sdata="langKeyword" value="image"><span class="keyword">image</span></span>, in SQL Server è consentita la conversione di tipi di dati <span sdata="langKeyword" value="varchar"><span class="keyword">varchar</span></span> in <span sdata="langKeyword" value="image"><span class="keyword">image</span></span> e non viene generata un'eccezione.</p></li></ul><p>SQL Server esegue l'impostazione bulk delle conversioni e restituisce gli errori al driver JDBC in caso di problemi. Le conversioni sul lato client non sono frequenti e vengono eseguite solo nel caso di valori <span sdata="langKeyword" value="date"><span class="keyword">date</span></span>, <span sdata="langKeyword" value="time"><span class="keyword">time</span></span>, <span sdata="langKeyword" value="timestamp"><span class="keyword">timestamp</span></span>, <span sdata="langKeyword" value="Boolean"><span class="keyword">Boolean</span></span> e <span sdata="langKeyword" value="String"><span class="keyword">String</span></span>.</p><p>Quando il tipo di dati colonna di SQL Server è <span sdata="langKeyword" value="XML"><span class="keyword">XML</span></span>, il valore dei dati deve essere un tipo <span sdata="langKeyword" value="XML"><span class="keyword">XML</span></span> valido. Quando si chiama il metodo setObject(byte[], SQLXML), setObject(inputStream, SQLXML) o setObject(Blob, SQLXML), il valore dei dati deve essere la rappresentazione di stringa esadecimale dei caratteri XML. Ad esempio: </p><div class="sampleCode"><span codeLanguage="other"><pre>&lt;hello&gt;world&lt;/hello&gt; = 0x3C68656C6C6F3E776F726C643C2F68656C6C6F3E </pre></span></div><p>Si noti che se i caratteri XML sono espressi in codifiche di caratteri specifiche, è necessario un indicatore dell'ordine dei byte (BOM, Byte-Order Mark).</p></div><span id="seeAlsoSpan"><h1 class="heading">Vedere anche</h1></span><div id="seeAlsoSection" class="section" name="collapseableSection" style=""><div class="seeAlsoStyle"><span sdata="link"><a href="7802328d-4d23-4775-9573-4169b127d258.htm">Informazioni sui tipi di dati del driver JDBC</a></span></div></div></div><div id="footer" class="section"><span id="feedbackarea">Inviare <a href="javascript:SubmitFeedback('DevDocs@Microsoft.com','','','','8.0.12060.10000','%0\dThank%20you%20for%20your%20feedback.%20The%20developer%20writing%20teams%20use%20your%20feedback%20to%20improve%20documentation.%20While%20we%20are%20reviewing%20your%20feedback,%20we%20may%20send%20you%20e-mail%20to%20ask%20for%20clarification%20or%20feedback%20on%20a%20solution.%20We%20do%20not%20use%20your%20e-mail%20address%20for%20any%20other%20purpose%20and%20we%20delete%20it%20after%20we%20finish%20our%20review.%0\AFor%20further%20information%20about%20the%20privacy%20policies%20of%20Microsoft,%20please%20see%20http://privacy.microsoft.com/it-it/default.aspx.%0\A%0\d','Customer%20Feedback');">commenti e suggerimenti</a> su questo argomento a Microsoft.</span><span id="copyrightarea"><p><a href="9bad553b-9e70-4696-8499-2e35f772a1e0.htm">© 2012 Microsoft. Tutti i diritti sono riservati.</a></p></span></div></div></body></html>