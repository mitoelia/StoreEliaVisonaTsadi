<html xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:MSHelp="http://msdn.microsoft.com/mshelp" xmlns:mshelp="http://msdn.microsoft.com/mshelp" xmlns:ddue="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:msxsl="urn:schemas-microsoft-com:xslt"><head><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8" /><META NAME="save" CONTENT="history" /><title>Utilizzo di tipi di dati avanzati</title><meta name="Language" content="it-it" /><meta name="System.Keywords" content="tipi di dati avanzati" /><meta name="Microsoft.Help.Id" content="b39461d3-48d6-4048-8300-1a886c00756d" /><meta name="Description" content="In Microsoft JDBC Driver per SQL Server vengono utilizzati i tipi di dati JDBC avanzati per convertire i tipi di dati di SQL Server in un formato comprensibile nel linguaggio di programmazione Java." /><meta name="Microsoft.Help.ContentType" content="Concepts" /><link rel="stylesheet" type="text/css" href="../local/Classic.css" /><script type="text/javascript" src="../scripts/EventUtilities.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/SplitScreen.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/Dropdown.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/script_manifold.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/script_feedBack.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/CheckboxMenu.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/CommonUtilities.js">&amp;nbsp;</script><script type="text/javascript" src="../local/script_main.js">&amp;nbsp;</script></head><body><div id="header"><table id="bottomTable" cellpadding="0" cellspacing="0"><tr><td align="left"><span id="headerBold">Utilizzo di tipi di dati avanzati</span></td></tr></table><table id="gradientTable"><tr><td class="nsrBottom" background="../icons/gradient.gif" /></tr></table></div><div id="mainSection"><div id="mainBody"><div class="introduction"><p>In Microsoft JDBC Driver per SQL Server vengono utilizzati i tipi di dati JDBC avanzati per convertire i tipi di dati di SQL Server in un formato comprensibile nel linguaggio di programmazione Java. </p></div><h1 class="heading">Osservazioni</h1><div id="sectionSection0" class="section" name="collapseableSection" style=""><p>Nella tabella seguente sono riportati i mapping predefiniti tra i tipi di dati avanzati di SQL Server, JDBC e del linguaggio di programmazione Java:</p><div class="tableSection"><table width="50%" cellspacing="2" cellpadding="5" frame="lhs"><tr><th><p>Tipi di SQL Server</p></th><th><p>Tipi JDBC (java.sql.Types)</p></th><th><p>Tipi del linguaggio Java</p></th></tr><tr><td><p>varbinary(max)</p><p>image</p></td><td><p>LONGVARBINARY</p></td><td><p>byte[] (default), Blob, InputStream, String</p></td></tr><tr><td><p>text</p><p>varchar(max)</p></td><td><p>LONGVARCHAR</p></td><td><p>String (default), Clob, InputStream</p></td></tr><tr><td><p>ntext</p><p>nvarchar(max)</p></td><td><p>LONGVARCHAR</p><p>LONGNVARCHAR (Java SE 6.0)</p></td><td><p>String (default), Clob, NClob (Java SE 6.0)</p></td></tr><tr><td><p>xml</p></td><td><p>LONGVARCHAR</p><p>SQLXML (Java SE 6.0)</p></td><td><p>String (default), InputStream, Clob, byte[],Blob, SQLXML (Java SE 6.0)</p></td></tr><tr><td><p>udt</p></td><td><p>VARBINARY</p></td><td><p>String (default), byte[], InputStream</p></td></tr></table></div><p>Nelle sezioni seguenti vengono forniti esempi di come sia possibile utilizzare il driver JDBC e i tipi di dati avanzati.</p></div><h1 class="heading">Tipi di dati BLOB, CLOB e NCLOB</h1><div id="sectionSection1" class="section" name="collapseableSection" style=""><p>Nel driver JDBC sono implementati tutti i metodi delle interfacce java.sql.Blob, java.sql.Clob e java.sql.NClob. </p><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>I valori CLOB possono essere utilizzati con i tipi di dati di SQL Server 2005 (o versioni successive) per valori di grandi dimensioni. In particolare, i tipi CLOB possono essere utilizzati con i tipi di dati <span sdata="langKeyword" value="varchar(max)"><span class="keyword">varchar(max)</span></span> e <span sdata="langKeyword" value="nvarchar(max)"><span class="keyword">nvarchar(max)</span></span>, i tipi BLOB con i tipi di dati <span sdata="langKeyword" value="varbinary(max)"><span class="keyword">varbinary(max)</span></span> e <span sdata="langKeyword" value="image"><span class="keyword">image</span></span>, mentre i tipi NCLOB con i tipi di dati <span sdata="langKeyword" value="ntext"><span class="keyword">ntext</span></span> e <span sdata="langKeyword" value="nvarchar(max)"><span class="keyword">nvarchar(max)</span></span>.</p></div></div><h1 class="heading">Tipi di dati per valori di grandi dimensioni</h1><div id="sectionSection2" class="section" name="collapseableSection" style=""><p>Nelle precedenti versioni di SQL Server l'utilizzo di tipi di dati per valori di grandi dimensioni richiedeva particolari operazioni di gestione. I tipi di dati per valori di grandi dimensioni sono quelli che superano la dimensione massima delle righe di 8 KB. In SQL Server è stato introdotto un identificatore max per i tipi di dati <span sdata="langKeyword" value="varchar"><span class="keyword">varchar</span></span>, <span sdata="langKeyword" value="nvarchar"><span class="keyword">nvarchar</span></span> e <span sdata="langKeyword" value="varbinary"><span class="keyword">varbinary</span></span>, per consentire l'archiviazione di valori fino a 2^31 byte. Le colonne delle tabelle e le variabili Transact-SQL possono specificare tipi di dati <span sdata="langKeyword" value="varchar(max)"><span class="keyword">varchar(max)</span></span>, <span sdata="langKeyword" value="nvarchar(max)"><span class="keyword">nvarchar(max)</span></span> o <span sdata="langKeyword" value="varbinary(max)"><span class="keyword">varbinary(max)</span></span>.</p><p>Gli scenari principali di utilizzo di tipi per valori di grandi dimensioni riguardano il recupero di tali tipi di dati da un database o l'aggiunta degli stessi a un database. Nelle sezioni seguenti vengono descritti i diversi approcci adottabili per eseguire queste attività.</p><h1 class="heading">Recupero di tipi per valori di grandi dimensioni da un database</h1><div class="subsection"><p>Quando si recupera un tipo di dati per valori di grandi dimensioni non binario, ad esempio <span sdata="langKeyword" value="varchar(max)"><span class="keyword">varchar(max)</span></span>, da un database, uno degli approcci adottabili consiste nel leggere i dati in questione come flusso di caratteri. Nell'esempio seguente viene utilizzato il metodo <a href="599cf463-e19f-4baa-bacb-513cad7c6cd8.htm">executeQuery</a> della classe <a href="ec24963c-8b51-4838-91e9-1fbfa2347451.htm">SQLServerStatement</a> per recuperare dati dal database e restituirli come set di risultati. Viene quindi utilizzato il metodo <a href="c70e210f-0288-47cc-9268-a29c45979729.htm">getCharacterStream</a> della classe <a href="eaffcff1-286c-459f-83da-3150778480c9.htm">SQLServerResultSet</a> per leggere i dati per valori di grandi dimensioni dal set di risultati.</p><div class="sampleCode"><span codeLanguage="other"><pre>ResultSet rs = stmt.executeQuery("SELECT TOP 1 * FROM Test1");
rs.next();
Reader reader = rs.getCharacterStream(2);</pre></span></div><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>Questo stesso approccio può essere utilizzato anche per i tipi di dati <span sdata="langKeyword" value="text"><span class="keyword">text</span></span>, <span sdata="langKeyword" value="ntext"><span class="keyword">ntext</span></span> e <span sdata="langKeyword" value="nvarchar(max)"><span class="keyword">nvarchar(max)</span></span>.</p></div><p>Quando si recupera un tipo di dati per valori di grandi dimensioni binario, ad esempio <span sdata="langKeyword" value="varbinary(max)"><span class="keyword">varbinary(max)</span></span>, da un database, è possibile adottare diversi approcci. L'approccio più efficace consiste nel leggere i dati come flusso binario, come nell'esempio seguente:</p><div class="sampleCode"><span codeLanguage="other"><pre>ResultSet rs = stmt.executeQuery("SELECT photo FROM mypics");
rs.next();
InputStream is = rs.getBinaryStream(2);</pre></span></div><p>È inoltre possibile utilizzare il metodo <a href="d16a0aea-6144-4fcb-bcbc-5d7daa36d327.htm">getBytes</a> per leggere i dati come matrice di byte, come nell'esempio seguente:</p><div class="sampleCode"><span codeLanguage="other"><pre>ResultSet rs = stmt.executeQuery("SELECT photo FROM mypics");
rs.next();
byte [] b = rs.getBytes(2);</pre></span></div><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>I dati possono essere letti anche come BLOB. Tuttavia, questo metodo è meno efficace dei due precedenti.</p></div></div><h1 class="heading">Aggiunta di tipi per valori di grandi dimensioni a un database</h1><div class="subsection"><p>Il caricamento di dati di grandi dimensioni con il driver JDBC funziona bene per i dati di dimensioni pari a quelle della memoria, e nel caso di dati di dimensioni maggiori di quelle della memoria, l'opzione principale è rappresentata dall'utilizzo di flussi. Tuttavia, il modo più efficace per caricare dati di grandi dimensioni è mediante interfacce di flusso.</p><p>È però possibile utilizzare anche stringhe o byte, come nell'esempio seguente:</p><div class="sampleCode"><span codeLanguage="other"><pre>PreparedStatement pstmt = con.prepareStatement("INSERT INTO test1 (c1_id, c2_vcmax) VALUES (?, ?)");
pstmt.setInt(1, 1);
pstmt.setString(2, htmlStr);
pstmt.executeUpdate();</pre></span></div><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>Questo approccio può essere utilizzato anche per valori archiviati in colonne <span sdata="langKeyword" value="text"><span class="keyword">text</span></span>, <span sdata="langKeyword" value="ntext"><span class="keyword">ntext</span></span> e <span sdata="langKeyword" value="nvarchar(max)"><span class="keyword">nvarchar(max)</span></span>.</p></div><p>Se nel server è presente una libreria di immagini ed è necessario caricare interi file di immagine binari in una colonna <span sdata="langKeyword" value="varbinary(max)"><span class="keyword">varbinary(max)</span></span>, il modo più efficace per eseguire tale attività con il driver JDBC consiste nell'utilizzare direttamente flussi, come nell'esempio seguente:</p><div class="sampleCode"><span codeLanguage="other"><pre>PreparedStatement pstmt = con.prepareStatement("INSERT INTO test1 (Col1, Col2) VALUES(?,?)");
File inputFile = new File("CLOBFile20mb.jpg");
FileInputStream inStream = new FileInputStream(inputFile);
int id = 1;
pstmt.setInt(1,id);
pstmt.setBinaryStream(2, inStream);
pstmt.executeUpdate();
inStream.close();</pre></span></div><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>L'utilizzo del metodo Clob o Blob non rappresenta un modo efficace di caricamento di dati di grandi dimensioni.</p></div></div><h1 class="heading">Modifica di tipi per valori di grandi dimensioni in un database</h1><div class="subsection"><p>Nella maggior parte dei casi, l'approccio consigliato per aggiornare o modificare valori di grandi dimensioni nel database consiste nel passare parametri mediante le classi <a href="a8481c06-fbba-432b-8c69-4f4619c20ad4.htm">SQLServerPreparedStatement</a> e <a href="30710a63-c05d-47d9-9cf9-c087a1c76373.htm">SQLServerCallableStatement</a>, utilizzando comandi Transact-SQL quali UPDATE, WRITE e SUBSTRING.</p><p>Se è necessario sostituire l'istanza di una parola in un file di testo di grandi dimensioni, quale ad esempio un file HTML archiviato, è possibile utilizzare un oggetto <b>Clob</b>, come nell'esempio seguente:</p><div class="sampleCode"><span codeLanguage="other"><pre>String SQL = "SELECT * FROM test1;";
Statement stmt = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);
ResultSet rs = stmt.executeQuery(SQL);
rs.next();

Clob clob = rs.getClob(2);
long pos = clob.position("dog", 1);
clob.setString(pos, "cat");
rs.updateClob(2, clob);
rs.updateRow();</pre></span></div><p>Inoltre, è possibile eseguire tutte le operazioni sul server e quindi passare solo i parametri a un'istruzione UPDATE preparata.</p><p>Per ulteriori informazioni sui tipi per valori di grandi dimensioni, vedere la sezione relativa all'utilizzo di tipi per valori di grandi dimensioni nella Documentazione online di SQL Server.</p></div></div><h1 class="heading">Tipo di dati XML</h1><div id="sectionSection3" class="section" name="collapseableSection" style=""><p>In SQL Server è disponibile un tipo di dati <span sdata="langKeyword" value="xml"><span class="keyword">xml</span></span> che consente di archiviare documenti e frammenti XML in un database di SQL Server. Il tipo di dati <span sdata="langKeyword" value="xml"><span class="keyword">xml</span></span> è un tipo di dati predefinito in SQL Server ed è simile ad altri tipi predefiniti quali <span sdata="langKeyword" value="int"><span class="keyword">int</span></span> e <span sdata="langKeyword" value="varchar"><span class="keyword">varchar</span></span>. Come accade con gli altri tipi predefiniti, è possibile utilizzare il tipo di dati <span sdata="langKeyword" value="xml"><span class="keyword">xml</span></span> come tipo di colonna quando si crea una tabella, come tipo di variabile, come tipo di parametro o come tipo restituito da una funzione oppure nelle funzioni Transact-SQL CAST e CONVERT.</p><p>Nel driver JDBC al tipo di dati <span sdata="langKeyword" value="xml"><span class="keyword">xml</span></span> può essere eseguito il mapping come stringa, matrice di byte, flusso o oggetto CLOB, BLOB oppure oggetto SQLXML. Il mapping predefinito è come stringa. A partire da Microsoft JDBC Driver versione 2.0, il driver JDBC offre il supporto per l'API di JDBC 4.0, in cui viene presentata l'interfaccia SQLXML. Tale interfaccia definisce i metodi per interagire e modificare i dati XML. Al tipo di dati <span sdata="langKeyword" value="SQLXML"><span class="keyword">SQLXML</span></span> viene eseguito il mapping al tipo di dati <span sdata="langKeyword" value="xml"><span class="keyword">xml</span></span> di SQL Server. Per ulteriori informazioni su come leggere e scrivere dati XML da e in un database relazionale con il tipo di dati Java <span sdata="langKeyword" value="SQLXML"><span class="keyword">SQLXML</span></span>, vedere <span sdata="link"><a href="32b7217e-1f0c-473d-9a45-176daa81584e.htm">Supporto dei dati XML</a></span>.</p><p>L'implementazione del tipo di dati <span sdata="langKeyword" value="xml"><span class="keyword">xml</span></span> nel driver JDBC consente di supportare quanto segue:</p><ul><li><p>Accesso al codice XML come stringa UTF-16 Java standard per la maggior parte degli scenari di programmazione comuni</p></li><li><p>Input di codice XML in formato UTF-8 e con altri tipi di codifica a 8 bit</p></li><li><p>Accesso al codice XML come matrice di byte, con un indicatore dell'ordine di byte (BOM) iniziale in caso di codifica in formato UTF-16 per l'interscambio con altri processori e file su disco XML</p></li></ul><p>SQL Server richiede un indicatore dell'ordine di byte (BOM) iniziale per il codice XML con codifica UTF-16. Questo elemento deve essere fornito dall'applicazione quando i valori dei parametri XML vengono forniti come matrici di byte. Nell'output di SQL Server i valori XML sono sempre presenti come stringhe UTF-16 senza indicatore dell'ordine di byte (BOM) né dichiarazione di codifica incorporata. Quando i valori XML vengono recuperati come byte[], BinaryStream o Blob, sono preceduti da un indicatore dell'ordine di byte (BOM) UTF-16.</p><p>Per ulteriori informazioni sul tipo di dati <span sdata="langKeyword" value="xml"><span class="keyword">xml</span></span>, vedere l'argomento "Tipo di dati XML" nella documentazione online di SQL Server.</p></div><h1 class="heading">Tipo di dati definito dall'utente</h1><div id="sectionSection4" class="section" name="collapseableSection" style=""><p>L'introduzione di tipi definiti dall'utente (UDT, User-Defined Type) in SQL Server 2005 estende il sistema di tipi SQL consentendo di archiviare oggetti e strutture di dati personalizzate in un database di SQL Server. I tipi di dati UDT possono contenere più tipi di dati e avere comportamenti diversi, differenziandosi dai tradizionali tipi di dati alias costituiti da un solo tipo di dati di sistema di SQL Server. I tipi di dati UDT vengono definiti utilizzando uno qualsiasi dei linguaggi supportati dalla funzionalità CLR (Common Language Runtime) di Microsoft .NET in grado di produrre codice verificabile, tra cui Microsoft Visual C# e Visual Basic .NET. I dati vengono esposti come campi e proprietà di una classe o una struttura basata su .NET Framework e i comportamenti vengono definiti dai metodi della classe o della struttura in questione. </p><p>In SQL Server è possibile utilizzare un tipo di dati UDT come definizione di colonna di una tabella, come variabile in un batch Transact-SQL o come argomento di una funzione o una stored procedure Transact-SQL.</p><p>Per ulteriori informazioni sui tipi di dati definiti dall'utente, vedere la sezione sull'utilizzo e la modifica delle istanze dei tipi definiti dall'utente nella documentazione online di SQL Server.</p></div><span id="seeAlsoSpan"><h1 class="heading">Vedere anche</h1></span><div id="seeAlsoSection" class="section" name="collapseableSection" style=""><div class="seeAlsoStyle"><span sdata="link"><a href="7802328d-4d23-4775-9573-4169b127d258.htm">Informazioni sui tipi di dati del driver JDBC</a></span></div></div></div><div id="footer" class="section"><span id="feedbackarea">Inviare <a href="javascript:SubmitFeedback('DevDocs@Microsoft.com','','','','8.0.12060.10000','%0\dThank%20you%20for%20your%20feedback.%20The%20developer%20writing%20teams%20use%20your%20feedback%20to%20improve%20documentation.%20While%20we%20are%20reviewing%20your%20feedback,%20we%20may%20send%20you%20e-mail%20to%20ask%20for%20clarification%20or%20feedback%20on%20a%20solution.%20We%20do%20not%20use%20your%20e-mail%20address%20for%20any%20other%20purpose%20and%20we%20delete%20it%20after%20we%20finish%20our%20review.%0\AFor%20further%20information%20about%20the%20privacy%20policies%20of%20Microsoft,%20please%20see%20http://privacy.microsoft.com/it-it/default.aspx.%0\A%0\d','Customer%20Feedback');">commenti e suggerimenti</a> su questo argomento a Microsoft.</span><span id="copyrightarea"><p><a href="9bad553b-9e70-4696-8499-2e35f772a1e0.htm">© 2012 Microsoft. Tutti i diritti sono riservati.</a></p></span></div></div></body></html>